# 유저 시나리오 기반 기능 정의, 요구사항 명세

## 상품 목록 조회

### 유저 시나리오
- 사용자는 상품 목록을 조회할 수 있다.
- 사용자는 특정 브랜드 필터 기능을 사용할 수 있다
- 사용자는 최신순, 가격순, 좋아요 순으로 정렬 할 수 있다. (디폴트 - 최신순)
- 사용자는 페이지, 페이지당 상품 수를 지정하여 상품 목록을 조회할 수 있다.

### 기능적 요구사항
- GET /api/v1/products 로 목록을 조회한다.
- 요청 파라미터
  - brandId(Optional) : 특정 브랜드의 상품만 필터링
  - sort : latest(기본), price_asc, likes_desc
  - page : 페이지 번호 (기본값 : 0)
    - 빈페이지 일 경우 성공, 빈화면 노출
  - size : 페이지당 상품 수(기본값 : 20)
- 에러처리

  | 조건            | HTTP  | message    |
  |---------------|---|-------------------|
  | 유효하지 않은 정렬 키  | 400 | 유효하지 않은 정렬 기준입니다. |
  | 비활성/미존재 브랜드   | 404 | 해당 브랜드를 찾을 수 없습니다 |

### 비기능적 요구사항
- **인덱스 설계**
  - `idx_products_brand_id`: 브랜드별 상품 필터링
  - `idx_products_created_at`: 최신순 정렬
  - `idx_products_price`: 가격순 정렬
  - `idx_products_total_likes`: 좋아요순 정렬
  - 복합 인덱스: `(brand_id, created_at)`, `(brand_id, price)`, `(brand_id, total_likes)` 고려
- **캐시 전략**
  - 상품 목록 조회 결과 Redis 캐시 적용
  - 캐시 키: `products:list:{brandId}:{sort}:{page}:{size}`
  - TTL: 5분 (상품 정보 변경 빈도 고려)

---
## 상품 상세 조회

### 유저 시나리오
- 사용자는 productId를 통해 상품 상세 정보를 확인할 수 있다.
- 사용자는 내가 해당 상품을 좋아요 했는지 여부를 확인할 수 있다.
- 사용자는 총 좋아요수를 확인 할수 있다.
- 사용자는 재고가 0일 경우 구매가 불가함을 인지할 수 있다.

### 기능적 요구사항
- GET /api/v1/products/{productId} 로 상세를 조회한다.
- 응답 파라미터
  - 상품 아이디, 브랜드 정보, 상품명, 설명, 가격, 재고, 총 좋아요 수
  - 좋아요 여부 : X-USER-ID가 있을 때만 포함(없으면 생략 또는 false)
- 제약사항
  -	productId 필수 없으면 404
  -	재고 0이면 "일시 품절" 상태(구매 불가) 안내
- 에러처리

  | 조건            | HTTP | message           |
  |---------------|-----|-------------------|
  | 비활성/미존재 상품 ID | 404 | 해당 상품을 찾을 수 없습니다. |

### 비기능적 요구사항
- **캐시 전략**
  - 상품 상세 정보 Redis 캐시 적용
  - 캐시 키: `product:detail:{productId}`
  - TTL: 10분
  - 무효화: 상품 정보 변경, 좋아요 등록/취소 시 캐시 삭제

---
## 브랜드 조회

### 유저 시나리오
- 사용자는 특정 브랜드의 기본 정보를 확인할 수 있다.
- 사용자는 해당 브랜드의 상품 목록을 조회할 수 있다.

### 기능적 요구사항
- GET /api/v1/brands/{brandId} 로 조회한다.
- 제약 사항
    - brandId 필수 없으면 404
- 에러처리

  | 조건                   | HTTP | message            |
  |----------------------|------|--------------------|
  | 비활성/미존재 브랜드 ID | 404 | 해당 브랜드를 찾을 수 없습니다. |


---
## 상품 좋아요 등록/취소 (멱등 동작)

### 유저 시나리오
- 로그인한 사용자만 좋아요 등록 및 취소할 수 있다.
- 사용자는 목록/상세에서 하트를 눌러 좋아요를 등록/취소할 수 있다.
- 좋아요 등록 요청이 여러번 와도 좋아요 등록 상태는 유지된다
- 좋아요 취소 요청이 여러번 와도 좋아요 취소 상태는 유지된다.

### 기능적 요구사항
- 등록: POST /api/v1/like/products/{productId}
- 취소: DELETE /api/v1/like/products/{productId}
- 제약사항
  - X-USER-ID 필수 없으면 404
  - productId 필수 없으면 404
  - 좋아요 동일 요청시에도 해당 상태를 유지한다.
- 에러처리

  | 조건                          | HTTP | message            |
  |-----------------------------|------|--------------------|
  | X-USER-ID 누락 or 유효하지 않는 사용자 | 404 | 해당 사용자를 찾을 수 없습니다. |
  | 비활성/미존재 상품 ID           | 404 | 해당 상품을 찾을 수 없습니다. |

### 비기능적 요구사항
- **비정규화**: Product 테이블에 `totalLikes` 필드 유지
  - 좋아요 등록 시: `Product.increaseLikes()` 호출
  - 좋아요 취소 시: `Product.decreaseLikes()` 호출
- **동시성 제어**: Product 엔티티에 `@Version` 낙관적 락 적용
  - 동일 상품에 대한 동시 좋아요 요청 시 정합성 보장
- **캐시 무효화**: 좋아요 등록/취소 시 해당 상품 캐시 삭제
  - `product:detail:{productId}` 캐시 evict
  - `products:list:*` 관련 캐시 evict (좋아요순 정렬 영향)

---
## 내가 좋아요 한 상품 목록 조회

### 유저 시나리오
- 로그인한 사용자는 좋아요한 목록을 볼 수 있다.

### 기능적 요구사항
- GET /api/v1/like/products
- 제약사항
  - X-USER-ID 필수 없으면 404
- 에러처리

  | 조건                          | HTTP | message            |
  |-----------------------------|------|--------------------|
  | X-USER-ID 누락 or 유효하지 않는 사용자 | 404 | 해당 사용자를 찾을 수 없습니다. |

### 비기능적 요구사항
- **인덱스**: `uk_product_like_user_product (user_id, product_id)` 유니크 인덱스 활용

---

## 주문 생성 및 결제 흐름 (재고 차감, PG/포인트 결제, 외부 시스템 연동)

### 유저 시나리오
- 사용자는 여러 상품을 한 번에 주문하고 포인트 또는 카드로 결제할 수 있다.
- 재고가 있을 경우 주문할 수 있다.
- 카드 정보 제공 시 카드 결제, 미제공 시 포인트 결제로 처리된다.
- 카드 결제 시 PG를 통해 비동기로 처리되며, 결제 완료까지 상태를 조회할 수 있다.

### 기능적 요구사항
- POST /api/v1/orders 로 주문 생성
- 요청 본문 예시
```json
{
  "items": [
    { "productId": 1, "quantity": 2 },
    { "productId": 3, "quantity": 1 }
  ],
  "cardInfo": {
    "cardType": "SAMSUNG",
    "cardNo": "1234-5678-9012-3456"
  }
}
```
- cardInfo가 없으면 포인트 결제(POINT_ONLY), 있으면 카드 결제(CARD_ONLY)
- 주문 처리 순서:
  1. 상품 재고 선차감 (productId 순 정렬로 데드락 방지)
  2. Order 생성 (PENDING)
  3. Payment 생성 (PENDING)
  4. 결제 실행:
     - 포인트 결제: 동기 처리 (트랜잭션 내 즉시 완료)
     - 카드 결제: 비동기 처리 (트랜잭션 커밋 후 PG 요청)
- 제약사항
  - 하나 이상의 상품을 주문해야한다.
  - 결제 실패 시 재고 자동 복구 (역순 처리)
- 에러처리

  | 조건 | HTTP | message |
  |------|------|---------|
  | 비활성/미존재 상품 ID | 404 | 해당 상품을 찾을 수 없습니다. |
  | 재고 부족 | 400 | {상품명} 상품의 재고가 부족합니다. |
  | 포인트 부족 (포인트 결제 시) | 400 | 포인트가 부족합니다. |

---

## 결제 상태 조회 및 PG 콜백

### 유저 시나리오
- 사용자는 주문의 결제 상태를 조회할 수 있다.
- 카드 결제 시 PG에서 콜백으로 최종 결과를 받는다.

### 기능적 요구사항

**결제 상태 조회**
- GET /api/v1/orders/{orderId}/payment
- 결제 상태가 PENDING인 경우 PG와 동기화하여 최신 상태 반환
- 응답 파라미터: orderId, status, paymentType, amount, pgTransactionId, failureReason

**PG 콜백 수신**
- POST /api/v1/payments/callback
- 요청 본문 예시
```json
{
  "transactionKey": "pg-transaction-id",
  "status": "SUCCESS",
  "reason": null
}
```
- 콜백 처리:
  - SUCCESS: Payment 성공, Order CONFIRMED
  - FAILED: Payment 실패, Order FAILED, 재고 복구

**주문 상태 (OrderStatus)**

| 상태 | 설명 |
|------|------|
| PENDING | 주문 요청 (초기 상태) |
| PAYING | 결제 진행 중 |
| CONFIRMED | 주문 완료 (결제 성공) |
| FAILED | 결제 실패 |
| CANCELLED | 주문 취소 |

**결제 타입 (PaymentType)**

| 타입 | 설명 |
|------|------|
| POINT_ONLY | 포인트만 사용 |
| CARD_ONLY | 카드만 사용 |
| MIXED | 포인트와 카드 혼합 (미구현) |

**결제 상태 (PaymentStatus)**

| 상태 | 설명 |
|------|------|
| PENDING | 결제 대기 |
| SUCCESS | 결제 성공 |
| FAILED | 결제 실패 |


---
## 주문 목록 조회

### 유저 시나리오
- 사용자는 내가 만든 주문 내역을 최신순으로 확인할 수 있다.

기능적 요구사항
- GET /api/v1/orders 로 목록을 조회한다.
- 제약사항
  - X-USER-ID 필수 없으면 404
- 에러처리

| 조건                          | HTTP | message            |
  |-----------------------------|------|--------------------|
| X-USER-ID 누락 or 유효하지 않는 사용자 | 404 | 해당 사용자를 찾을 수 없습니다. |

---
## 주문 단일 상세 조회

### 유저 시나리오
- 사용자는 특정 주문의 상세를 확인할 수 있다.

### 기능적 요구사항
- GET /api/v1/orders/{orderId}
- 제약사항
    - X-USER-ID 필수 없으면 404
- 에러처리

  | 조건                          | HTTP | message            |
  |-----------------------------|------|--------------------|
  | X-USER-ID 누락 or 유효하지 않는 사용자 | 404 | 해당 사용자를 찾을 수 없습니다. |

---

## 성능 최적화 전략 (Round 5)

### 인덱스 설계 원칙
1. **카디널리티가 높은 컬럼**에 인덱스 적용
2. **복합 인덱스**: WHERE 조건 + ORDER BY 순서 고려
3. **EXPLAIN** 분석으로 인덱스 사용 여부 확인

### 캐시 전략
| 대상 | 캐시 키 패턴 | TTL | 무효화 조건 |
|-----|------------|-----|----------|
| 상품 상세 | `product:detail:{id}` | 10분 | 상품 수정, 좋아요 변경 |
| 상품 목록 | `products:list:{params}` | 5분 | 상품 추가/수정/삭제 |

### 비정규화 전략
- **Product.totalLikes**: 좋아요 수 집계를 위한 JOIN 제거
- 동시성 제어: `@Version` 낙관적 락으로 정합성 보장

---

## Resilience 전략 (Round 6)

### PG 연동 시 복원력 패턴

| 패턴 | 설정값 | 목적 |
|------|--------|------|
| Timeout | 5초 | PG 무한 대기 방지, 스레드 자원 보호 |
| Retry | 최대 3회, 1초 대기 | 일시적 네트워크 실패 복구 |
| Circuit Breaker | 50% 실패율, 10초 OPEN | PG 장애 시 연쇄 장애 방지 |
| Fallback | PENDING 상태 반환 | 사용자에게 명확한 상태 전달 |

### 동시성 제어
- 상품 재고: 낙관적 락 (@Version)
- 주문 생성 시 productId 순 정렬로 데드락 방지
- 좋아요: Unique Constraint로 중복 방지

### 멱등성 보장
- Order 상태 전이: 동일 상태 재시도 시 경고 로그만 출력, 예외 미발생
- PG 콜백: pgTransactionId로 중복 처리 방지

### 트랜잭션 설계
- 포인트 결제: 단일 트랜잭션 내 완료 (동기)
- 카드 결제: 트랜잭션 커밋 후 PG 요청 (TransactionSynchronization)
- 결제 실패 시: 별도 트랜잭션에서 재고 복구
